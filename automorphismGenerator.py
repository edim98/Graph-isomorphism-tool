from permv2 import *
from basicpermutationgroup import *
from graph import *
from individualization import balanced, bijection, disjointUnion
from refined_colouring import refine_colour

"""
File containing the algorithm for counting the number of automorphihsms using generating sets.
Based on the algorithm ideas of Lecture 4.
"""

def get_frequencies(coloring):
    maxvalue = -1
    for i in coloring:
        maxvalue = max(maxvalue, i)
    frequency1 = [0]*(maxvalue + 1)

    for i in coloring:
        frequency1[i] += 1

    return frequency1

def compute_order(H):
    """
    Compute the order of a generating set for a permutation group.
    :param H: A list of permutation objects representing the generating set.
    :return: The order of the generating set.
    """
    if len(H) == 1 and H[0].istrivial():
        return 1
    alpha = FindNonTrivialOrbit(H)
    if alpha is not None:
        orbitAlpha = Orbit(H, alpha, returntransversal = False)
        stabilizerAlpha = Stabilizer(H, alpha)
        orderOrbit = len(orbitAlpha)
        if len(stabilizerAlpha) == 0:
            return orderOrbit
        else:
            return orderOrbit * compute_order(stabilizerAlpha)


def is_permutation_member(f, H):
    """
    Procedure for checking if a permutation belongs to a generating set of a permutation group.
    :param f: A permutation object.
    :param H: A list of permutation objects representing the generating set.
    :return: True if the permutation belongs to the group. False, otherwise.
    """
    if len(H) == 0:
        return f.istrivial()
    if f.istrivial():
        return True
    if len(H) == 1 and H[0].istrivial():
        return False

    alpha = FindNonTrivialOrbit(H)
    orbit, transversal = Orbit(H, alpha, returntransversal = True)
    beta = f.P[alpha]

    if beta not in orbit:
        return False
    else:
        stabilizerAlpha = Stabilizer(H, alpha)
        u = transversal[orbit.index(beta)]
        inverseOfU = -u
        newPerm = inverseOfU * f

        return is_permutation_member(newPerm, stabilizerAlpha)


def create_permutation(lenG, dll):
    """
    Create a permutation object from a list of DLL objects generated by a bjiective colouring.
    Each colour class has two elements x and y such that x maps to y.
    :param lenG: The size of the graph which is equal to the size of the permutation.
    :param dll: An array of differently coloured DLL objects.
    :return: A permutation object representing a bijective colouring.
    """
    lenDll = len(dll)
    mapping = [0] * lenG
    for i in range(lenDll):
        d = dll[i]
        if d.size > 0:
            c1 = d.start.state % lenG
            c2 = d.end.state % lenG
            mapping[c1] = c2
    try:
        p = permutation(lenG, mapping = mapping)
    except:
        return None
    return p


def generateAutomorphism(G, D, I, X, lenSimpleG, trivial):
    """
    Procedure for computing the generating set for the automorphism group.
    :param G: The disjoint-union of the graph with a copy of itself.
    :param D: The list of chosen vertices from the graph.
    :param I: The list of chosen vertices from the copy of the first graph.
    :param X: The generating set computed so far.
    :param lenSimpleG: The length of the original graph.
    :param trivial: Flag which keeps track of where the recursion is at the level of a trivial node or not.
    :return: The generating set for the automorphism group.
    """
    max_color = 1
    colorings = [0] * len(G.vertices)
    dll = None
    if D != [] and I != []:  # If the lists are not empty, proceed to build an initial colouring.
        for i in D:
            colorings[i.label] = max_color
            max_color += 1

        max_color = 1
        for j in I:
            colorings[j.label] = max_color
            max_color += 1

        colorings, dll = refine_colour(G, colorings)  # Attempt to refine the colouring.

    frequency = get_frequencies(colorings)  # Check the frequency of each colour.

    if not balanced(frequency):  # If the colouring is not balanced, then return one step.
        return False

    if bijection(frequency):  # If the colouring defines a bijection:
        f = create_permutation(lenSimpleG, dll)  # Create the permutation of the colouring.
        if f is None:
            return False
        elif not is_permutation_member(f, X):  # Check if it is a member of the generating set computed so far.
            X.append(f)  # Add it, if new.
            return True  # Return to the last trivial node.
        return False  # Else return one step.

    chosenColor = -1
    for i in range(len(frequency)):  # Choose a new branching colour class.
        if frequency[i] >= 4:
            chosenColor = i
            break

    chosenVertex = None  # Choose a new branching vertex x.
    lenG = len(G.vertices)
    for i in range(lenG//2):
        if colorings[i] == chosenColor:
            vertex = G.vertices[i]
            if vertex not in D:
                chosenVertex = vertex
                D.append(vertex)
                break

    returnToAncestor = False
    for i in range(lenG//2, lenG):  # Try different values for vertex y.
        if colorings[i] == chosenColor:
            vertex = G.vertices[i]
            if vertex not in I:
                if vertex.degree == chosenVertex.degree:
                    I.append(vertex)

                    if vertex.label % lenSimpleG != chosenVertex.label % lenSimpleG:
                        # If the next recursion step does not lie on a trivial node set flag to False.
                        returnToAncestor = generateAutomorphism(G, D, I, X, lenSimpleG, False)
                    else:
                        # Else set the flag to True.
                        returnToAncestor = generateAutomorphism(G, D, I, X, lenSimpleG, True)

                    I.remove(vertex)
                    if returnToAncestor and not trivial:
                        break
    D.remove(chosenVertex)
    return returnToAncestor


def countAutomorphism(g1, g2):
    """
    Procedure called from 'main.py'.
    Attempts to compute the number of automorphisms between graphs g1 and g2.
    :param g1: The first graph.
    :param g2: The second graph.
    :return: The number of automorphisms between the two graphs.
    """
    G = disjointUnion(g1, g2)
    X = []
    generateAutomorphism(G, [], [], X, len(g2), True)
    return compute_order(X)
